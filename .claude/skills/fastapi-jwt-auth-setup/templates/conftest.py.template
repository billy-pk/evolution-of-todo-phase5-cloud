"""
Test Fixtures for JWT Authentication

Add these fixtures to your tests/conftest.py to mock JWT authentication
during testing without requiring real JWT tokens.
"""

import pytest
from fastapi.testclient import TestClient
from fastapi import Request
from unittest.mock import MagicMock

# Import your app components (adjust paths as needed)
from main import create_app
from middleware import JWTBearer
# from routes.tasks import verify_user_access  # Uncomment if you have this dependency


@pytest.fixture(scope="function")
def client(test_db):
    """
    Create a test client with mocked JWT validation.

    This fixture:
    1. Creates the FastAPI app
    2. Overrides JWTBearer to bypass actual token validation
    3. Injects a test user_id into request.state
    4. Returns a TestClient for making requests

    Usage:
        def test_protected_endpoint(client):
            response = client.get("/api/test-user/tasks")
            assert response.status_code == 200
    """
    app = create_app()

    # Override JWTBearer to bypass actual token validation
    async def override_jwt_bearer(request: Request):
        # Inject a test user_id into request.state
        # This simulates what the real JWTBearer middleware does
        request.state.user_id = "test_user_123"
        return "mock_token"

    app.dependency_overrides[JWTBearer] = override_jwt_bearer

    # Optional: Override verify_user_access for more flexible testing
    # Uncomment if you have a verify_user_access dependency
    # async def mock_verify_user_access(request: Request, user_id: str):
    #     """In tests, allow any user_id without strict validation"""
    #     return user_id
    #
    # app.dependency_overrides[verify_user_access] = mock_verify_user_access

    with TestClient(app) as c:
        yield c

    # Clean up dependency overrides
    app.dependency_overrides.clear()


@pytest.fixture
def authenticated_headers():
    """
    Helper fixture for authenticated request headers in tests.

    Returns:
        dict: Headers with Authorization Bearer token

    Usage:
        def test_with_headers(client, authenticated_headers):
            response = client.get("/api/tasks", headers=authenticated_headers)
            assert response.status_code == 200
    """
    return {
        "Authorization": "Bearer test_token_123",
        "Content-Type": "application/json"
    }


@pytest.fixture
def test_user_id():
    """
    Consistent test user ID across tests.

    Returns:
        str: Test user ID

    Usage:
        def test_user_isolation(client, test_user_id):
            response = client.get(f"/api/{test_user_id}/tasks")
            assert response.status_code == 200
    """
    return "test_user_123"


@pytest.fixture
def another_test_user_id():
    """
    Another test user ID for testing multi-tenant isolation.

    Returns:
        str: Another test user ID

    Usage:
        def test_cannot_access_other_user(client, test_user_id, another_test_user_id):
            # Create resource for test_user_id
            response = client.post(f"/api/{test_user_id}/tasks", json={"title": "Task"})
            task_id = response.json()["id"]

            # Try to access as another_test_user_id (should fail)
            response = client.get(f"/api/{another_test_user_id}/tasks/{task_id}")
            assert response.status_code == 403
    """
    return "test_user_456"


@pytest.fixture
def mock_jwt_payload():
    """
    Mock JWT payload for testing token parsing.

    Returns:
        dict: Sample JWT payload

    Usage:
        def test_jwt_parsing(mock_jwt_payload):
            assert mock_jwt_payload["user_id"] == "test_user_123"
            assert "exp" in mock_jwt_payload
    """
    import time
    from datetime import datetime, timedelta

    return {
        "user_id": "test_user_123",
        "email": "test@example.com",
        "exp": int((datetime.utcnow() + timedelta(hours=1)).timestamp()),
        "iat": int(datetime.utcnow().timestamp()),
    }


# Advanced: Mock JWKS client for integration testing
@pytest.fixture
def mock_jwks_client(monkeypatch):
    """
    Mock PyJWKClient for integration testing without real JWKS endpoint.

    This fixture mocks the JWKS client used by the middleware to
    avoid making real HTTP requests during tests.

    Usage:
        def test_jwt_validation(mock_jwks_client):
            # JWT validation will use mocked JWKS client
            # No real HTTP requests to auth provider
            pass
    """
    from unittest.mock import MagicMock
    import jwt

    # Create a mock signing key
    mock_signing_key = MagicMock()
    mock_signing_key.key = "mock_secret_key"

    # Create a mock JWKS client
    mock_client = MagicMock()
    mock_client.get_signing_key_from_jwt.return_value = mock_signing_key

    # Patch the jwks_client in middleware module
    monkeypatch.setattr("middleware.jwks_client", mock_client)

    return mock_client


# Example test cases using the fixtures
def test_jwt_required_returns_401_without_auth(client):
    """
    Test that endpoints return 401 when no authentication is provided.

    Note: This test may pass because of the override_jwt_bearer fixture.
    To test actual 401 behavior, create a separate client without overrides.
    """
    # Create a client without JWT override for this specific test
    from main import create_app
    app = create_app()

    with TestClient(app) as test_client:
        response = test_client.get("/api/test-user/tasks")
        assert response.status_code == 401
        assert "detail" in response.json()


def test_jwt_user_id_mismatch_returns_403(client, test_user_id, another_test_user_id):
    """
    Test that accessing another user's resources returns 403.

    This test verifies multi-tenant isolation.
    """
    # If you have verify_user_access dependency, this should work
    # Otherwise, adjust based on your implementation
    response = client.get(f"/api/{another_test_user_id}/tasks")

    # Depending on implementation, this might be 401 or 403
    # Adjust assertion based on your actual behavior
    assert response.status_code in [401, 403]
