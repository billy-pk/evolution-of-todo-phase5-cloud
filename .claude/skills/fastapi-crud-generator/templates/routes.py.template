"""
{ModelName} CRUD Endpoints

Generated by fastapi-crud-generator skill
Resource: {resources} (/{user_id}/{resources})
Multi-tenant: {multi_tenant}
"""

from fastapi import APIRouter, Depends, HTTPException, Path, Query, Request
from sqlmodel import Session, select
from typing import Optional, Literal
from uuid import UUID

from db import get_session
from models import {ModelName}
from schemas import {ModelName}Create, {ModelName}Update, {ModelName}Response, {ModelName}ListResponse

router = APIRouter(tags=["{resources}"])


def verify_user_access(request: Request, user_id: str = Path(...)) -> str:
    """
    Verify user_id in URL matches user_id from JWT token.

    Args:
        request: FastAPI request with user_id in state (from JWTBearer middleware)
        user_id: User ID from URL path parameter

    Returns:
        Validated user_id

    Raises:
        HTTPException: 401 if not authenticated, 403 if user_id mismatch
    """
    token_user_id = getattr(request.state, "user_id", None)

    if not token_user_id:
        raise HTTPException(
            status_code=401,
            detail="Authentication required"
        )

    if token_user_id != user_id:
        raise HTTPException(
            status_code=403,
            detail="Access denied: Cannot access another user's {resources}"
        )

    return user_id


@router.post("/{user_id}/{resources}", response_model={ModelName}Response, status_code=201)
async def create_{resource}(
    {resource}_data: {ModelName}Create,
    user_id: str = Depends(verify_user_access),
    session: Session = Depends(get_session)
):
    """
    Create a new {resource} for the authenticated user.

    Args:
        {resource}_data: Data for creating the {resource}
        user_id: Validated user ID from JWT
        session: Database session

    Returns:
        Created {resource} with generated ID and timestamps

    Raises:
        401: If not authenticated
        403: If user_id mismatch
        422: If validation fails
    """
    {resource} = {ModelName}(
        user_id=user_id,
        **{resource}_data.model_dump()
    )

    session.add({resource})
    session.commit()
    session.refresh({resource})

    return {ModelName}Response.model_validate({resource})


@router.get("/{user_id}/{resources}", response_model={ModelName}ListResponse)
async def list_{resources}(
    user_id: str = Depends(verify_user_access),
    session: Session = Depends(get_session),
    skip: int = Query(0, ge=0, description="Number of records to skip"),
    limit: int = Query(100, ge=1, le=100, description="Maximum number of records to return"),
    # Add custom filters here as needed
    # status: Optional[str] = Query(None, description="Filter by status"),
    # search: Optional[str] = Query(None, description="Search in title"),
):
    """
    List all {resources} for the authenticated user.

    Args:
        user_id: Validated user ID from JWT
        session: Database session
        skip: Offset for pagination (default: 0)
        limit: Max number of results (default: 100, max: 100)

    Returns:
        List of {resources} with total count

    Raises:
        401: If not authenticated
        403: If user_id mismatch
    """
    # Base query: filter by user_id and order by created_at DESC
    query = select({ModelName}).where(
        {ModelName}.user_id == user_id
    ).order_by(
        {ModelName}.created_at.desc()
    )

    # Add custom filters here
    # if status:
    #     query = query.where({ModelName}.status == status)
    # if search:
    #     query = query.where({ModelName}.title.contains(search))

    # Apply pagination
    query = query.offset(skip).limit(limit)

    {resources} = session.exec(query).all()

    # Convert to response models
    {resource}_responses = [{ModelName}Response.model_validate(r) for r in {resources}]

    return {ModelName}ListResponse(
        {resources}={resource}_responses,
        total=len({resources})
    )


@router.get("/{user_id}/{resources}/{id}", response_model={ModelName}Response)
async def get_{resource}(
    id: UUID,
    user_id: str = Depends(verify_user_access),
    session: Session = Depends(get_session)
):
    """
    Get a single {resource} by ID.

    Args:
        id: {ModelName} ID
        user_id: Validated user ID from JWT
        session: Database session

    Returns:
        The requested {resource}

    Raises:
        401: If not authenticated
        403: If user_id mismatch or {resource} doesn't belong to user
        404: If {resource} not found
    """
    {resource} = session.get({ModelName}, id)

    if not {resource}:
        raise HTTPException(
            status_code=404,
            detail="{ModelName} not found"
        )

    # Verify ownership
    if {resource}.user_id != user_id:
        raise HTTPException(
            status_code=403,
            detail="Access denied: {ModelName} belongs to another user"
        )

    return {ModelName}Response.model_validate({resource})


@router.put("/{user_id}/{resources}/{id}", response_model={ModelName}Response)
async def update_{resource}(
    id: UUID,
    {resource}_data: {ModelName}Update,
    user_id: str = Depends(verify_user_access),
    session: Session = Depends(get_session)
):
    """
    Update a {resource}.

    Args:
        id: {ModelName} ID
        {resource}_data: Updated {resource} data
        user_id: Validated user ID from JWT
        session: Database session

    Returns:
        Updated {resource} with new updated_at timestamp

    Raises:
        401: If not authenticated
        403: If user_id mismatch or {resource} doesn't belong to user
        404: If {resource} not found
        422: If validation fails
    """
    {resource} = session.get({ModelName}, id)

    if not {resource}:
        raise HTTPException(
            status_code=404,
            detail="{ModelName} not found"
        )

    # Verify ownership
    if {resource}.user_id != user_id:
        raise HTTPException(
            status_code=403,
            detail="Access denied: Cannot update another user's {resource}"
        )

    # Update only provided fields (exclude_unset=True)
    {resource}.sqlmodel_update({resource}_data.model_dump(exclude_unset=True))

    # Update timestamp
    from datetime import datetime
    {resource}.updated_at = datetime.utcnow()

    session.add({resource})
    session.commit()
    session.refresh({resource})

    return {ModelName}Response.model_validate({resource})


@router.delete("/{user_id}/{resources}/{id}", status_code=204)
async def delete_{resource}(
    id: UUID,
    user_id: str = Depends(verify_user_access),
    session: Session = Depends(get_session)
):
    """
    Delete a {resource}.

    Args:
        id: {ModelName} ID
        user_id: Validated user ID from JWT
        session: Database session

    Returns:
        204 No Content on success

    Raises:
        401: If not authenticated
        403: If user_id mismatch or {resource} doesn't belong to user
        404: If {resource} not found
    """
    {resource} = session.get({ModelName}, id)

    if not {resource}:
        raise HTTPException(
            status_code=404,
            detail="{ModelName} not found"
        )

    # Verify ownership
    if {resource}.user_id != user_id:
        raise HTTPException(
            status_code=403,
            detail="Access denied: Cannot delete another user's {resource}"
        )

    session.delete({resource})
    session.commit()

    return None
